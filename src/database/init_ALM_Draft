// src/database/init.ts
import sqlite3 from 'sqlite3';
import path from 'path';
import bcrypt from 'bcryptjs';

const dbPath = path.resolve(process.cwd(), 'src/campus_management.db');
let db: sqlite3.Database | null = null;

export const getDb = (): sqlite3.Database => {
  if (!db) {
    db = new sqlite3.Database(dbPath, (err) => {
      if (err) {
        console.error('Error opening database:', err);
      } else {
        console.log('Connected to SQLite database');
      }
    });
  }
  return db;
};

// --- small promise wrappers for sqlite3 callbacks ---
const run = (db: sqlite3.Database, sql: string, params: any[] = []): Promise<void> => {
  return new Promise((resolve, reject) => {
    db.run(sql, params, (err) => {
      if (err) reject(err);
      else resolve();
    });
  });
};

const get = <T = any>(db: sqlite3.Database, sql: string, params: any[] = []): Promise<T | undefined> => {
  return new Promise((resolve, reject) => {
    db.get(sql, params, (err, row) => {
      if (err) reject(err);
      else resolve(row as T);
    });
  });
};

// NEW: list helper
const all = <T = any>(db: sqlite3.Database, sql: string, params: any[] = []): Promise<T[]> => {
  return new Promise((resolve, reject) => {
    db.all(sql, params, (err, rows) => {
      if (err) reject(err);
      else resolve(rows as T[]);
    });
  });
};

export const initializeDatabase = async (): Promise<void> => {
  const database = getDb();

  // --- USERS TABLE ---
  await run(database, `
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      email TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      name TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'student',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // --- BOOKINGS TABLE ---
  await run(database, `
    CREATE TABLE IF NOT EXISTS bookings (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      resource_type TEXT NOT NULL,
      resource_name TEXT NOT NULL,
      start_time DATETIME NOT NULL,
      end_time DATETIME NOT NULL,
      status TEXT DEFAULT 'pending',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id)
    )
  `);

  // --- EVENTS TABLE ---
  await run(database, `
    CREATE TABLE IF NOT EXISTS events (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      description TEXT,
      location TEXT,
      start_time DATETIME NOT NULL,
      end_time DATETIME NOT NULL,
      organizer_id INTEGER NOT NULL,
      category TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (organizer_id) REFERENCES users(id)
    )
  `);

  // --- MAINTENANCE REQUESTS TABLE ---
  await run(database, `
    CREATE TABLE IF NOT EXISTS maintenance_requests (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      title TEXT NOT NULL,
      description TEXT NOT NULL,
      location TEXT NOT NULL,
      priority TEXT DEFAULT 'medium',             -- low | medium | high | urgent (free text for compatibility)
      status TEXT DEFAULT 'pending',              -- pending | in_progress | completed | cancelled
      assigned_to INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id),
      FOREIGN KEY (assigned_to) REFERENCES users(id)
    )
  `);

  // Keep updated_at fresh when rows change
  await run(database, `
    CREATE TRIGGER IF NOT EXISTS trg_maint_requests_updated_at
    AFTER UPDATE ON maintenance_requests
    FOR EACH ROW
    BEGIN
      UPDATE maintenance_requests
      SET updated_at = CURRENT_TIMESTAMP
      WHERE id = OLD.id;
    END;
  `);

  // Helpful indexes for faster queries
  await run(database, `CREATE INDEX IF NOT EXISTS idx_maint_status       ON maintenance_requests(status)`);
  await run(database, `CREATE INDEX IF NOT EXISTS idx_maint_priority     ON maintenance_requests(priority)`);
  await run(database, `CREATE INDEX IF NOT EXISTS idx_maint_assigned_to  ON maintenance_requests(assigned_to)`);
  await run(database, `CREATE INDEX IF NOT EXISTS idx_maint_user_id      ON maintenance_requests(user_id)`);

  // --- DEFAULT USERS ---
  const adminPassword = await bcrypt.hash('admin123', 10);
  const maintenancePassword = await bcrypt.hash('m123123', 10);

  // Default Admin
  const existingAdmin = await get(database, 'SELECT id FROM users WHERE email = ?', ['admin@campus.edu']);
  if (!existingAdmin) {
    await run(database,
      'INSERT INTO users (email, password, name, role) VALUES (?, ?, ?, ?)',
      ['admin@campus.edu', adminPassword, 'Admin User', 'admin']
    );
    console.log('Default admin user created: admin@campus.edu / admin123');
  }

  // Default Maintenance
  const existingMaintenance = await get(database, 'SELECT id FROM users WHERE email = ?', ['maintenance@campus.edu']);
  if (!existingMaintenance) {
    await run(database,
      'INSERT INTO users (email, password, name, role) VALUES (?, ?, ?, ?)',
      ['maintenance@campus.edu', maintenancePassword, 'Maintenance User', 'maintenance']
    );
    console.log('Default maintenance user created: maintenance@campus.edu / m123123');
  }

  console.log('Database tables initialized successfully');
};

// Export helpers so your services/routes can import them
export { run, get, all, dbPath };
